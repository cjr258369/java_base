# 快速幂
### lc题号：50. Pow(x, n)
#### 快速幂算法，有递归和迭代两个版本。旨在快速平方求幂（Exponentiation by squaring，平方求幂）是一种简单而有效的小算法，它可以以 ![[公式]](https://www.zhihu.com/equation?tex=O%28%5Clog+n%29) 的时间复杂度计算乘方。

### 原理：
#### 让我们先来思考一个问题：7的10次方，怎样算比较快？

**方法1：**最朴素的想法，7x7=49，49x7=343，... 一步一步算，共进行了9次乘法。但这样算无疑太慢了，尤其对计算机的CPU而言，每次运算只乘上一个个位数，无疑太屈才了。这时我们想到，也许可以拆分问题。

**方法2：**先算7的5次方，即7x7x7x7x7，再算它的平方，共进行了**5次**乘法。但这并不是最优解，因为对于“7的5次方”，我们仍然可以拆分问题。

**方法3：**先算7x7得49，则7的5次方为49x49x7，再算它的平方，共进行了**4次**乘法。模仿这样的过程，我们得到一个在 ![[公式]](https://www.zhihu.com/equation?tex=O%28%5Clog+n%29) 时间内计算出幂的算法，也就是快速幂。

以下均为java 代码实现，同时如果求的幂为负数时，比如求 7 的 -10 次方，只需先求出 7 的 10 次方，再取倒数即可，即： 1 / 7 的10次方。

#### 递归快速幂【java代码】

快速计算a的n次方，直接用二分的思路：

1. 如果 n 是偶数（不为0），那么就先计算 a 的 n/2 次方，然后平方。
2. 如果n是奇数，那么就先计算 a 的 n-1 次方，再乘上 a 即可。
3. 因此整体递归的出口是 a 的 0 次方，为 1。

代码：

```java
/**
* 快速求 a 的 n 次方
**/
public static double qpow(int a , int n){
	long N = n;
	//大于等于0，则无需取倒数，小于0，则先求出 -N 次幂，最后再取倒数。
	return N>=0? quickMul(a,N) : 1.0 / quickMul(a,-N);
}

public static double quickMul(int a , int n){
	if( n==0 ){
		return 1.0;
	}
	递归传入n的一半，直到n无法分解
	double y = quickMul(a,n/2);
	//如果指数不是偶数，要补回一个x，偶数则无需补
	return n%2 == 0 ? y*y : y*y*x;
}
```

如果结果非常大需要取模的话：（仅用正数示例）

```java
public final static MOD = 1000000007;
public static long qpow(int a,int n){
	if( n == 0){
		return 1;
	}else if( n%2 == 1 ){
		return qpow(a,n-1) * a % MOD;
	}else{
		long temp = qpow( a , n) % MOD;
		return temp * temp % MOD;
	}
}
```

递归简洁，但会产生额外的栈空间开销，所以下面迭代就是把递归改为循环，避免对占空间的大量占用。

另外还可以进一步优化运行速度比如：1. 可以把指数除2的动作优化为位运算：n >>= 1;  2. 判断指数奇偶性，也可以用位运算：(n &1) == 1

**复杂度分析**

- 时间复杂度：O(log n)，即为对 n 进行二进制拆分的时间复杂度。
- 空间复杂度：O(log n)，即为递归的层数。这是由于递归的函数调用会使用栈空间。



#### 迭代快速幂（非递归快速幂）

迭代版本的快速幂，对递归版本的快速幂做了进一步优化，把指数也进行了位运算。为什么指数也可以分解为位运算呢？把一个公式展开来，稍微找一下规律即可：

以求 m 的 77 次方为例：

*m*→*m*2→*m*4→+*m*9→+*m*19→*m*38→+*m*77

1. 77为奇数，需要补上额外的m，77/2 = 38 ，所以是  m 乘 m 的38次方 乘 m的38次方 （m贡献了1次）
2. 38是偶数，38/2 = 19，所以是 m的19次方 乘 m的19次方（m贡献了0次）
3. 19是奇数，需要补上额外的m，19/2 = 9 ，所以是 m 乘 m的9次方 乘 m的9次方 （m又再贡献了1次）
4. 9是奇数，需要补上额外的m，9/2 = 4 ，所以是 m 乘 m的4次方 乘 m的4次方（m又再贡献了1次）

m产生贡献的位置，当好对应77的二进制（1001101）中的每个1。

因此借助整数的二进制拆分，就可以得到迭代计算的方法，一般地，如果指数 n 的二进制拆分为

*n*=2*i*0+2*i*1+⋯+2*i**k*

那么幂运算可以拆分为：

*x**n*=*x*2*i*0×*x*2*i*1×⋯×*x*2*i**k*

详见下方两图参悟：

![快速幂图片2](/Users/jacksteve/Downloads/快速幂图片2.png)



![快速幂图片1](/Users/jacksteve/Downloads/快速幂图片1.jpg)

迭代的整体代码为：

```java
    public double myPow(double x, int n) {
        long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }

    public double quickMul(double x, long N) {
        double ans = 1.0;
        // 贡献的初始值为 x
        double x_contribute = x;
        // 在对 N 进行二进制拆分的同时计算答案
        while (N > 0) {
            if (N % 2 == 1) {
                // 如果 N 二进制表示的最低位为 1，那么需要计入贡献
                ans *= x_contribute;
            }
            // 将贡献不断地平方
            x_contribute *= x_contribute;
            // 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可
            N /= 2;
        }
        return ans;
    }
```



**复杂度分析**

- 时间复杂度：O(log n)，即为对 n 进行二进制拆分的时间复杂度。
- 空间复杂度：O(1)。
